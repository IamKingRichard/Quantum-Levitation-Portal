<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Levitation Threshold + Robust Confinement + Constrained Optimization (Disk + Yukawa)</title>
  <style>
    :root{
      --bg:#0b1220; --panel:#111c33; --text:#cbd5e1; --muted:#94a3b8;
      --accent:#3b82f6; --good:#10b981; --warn:#f59e0b; --bad:#ef4444; --line:#23304a;
    }
    *{box-sizing:border-box}
    body{
      margin:0; padding:14px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:linear-gradient(180deg,var(--bg),#070b14);
      color:var(--text);
    }
    h1{margin:0 0 10px; font-size:18px; font-weight:700}
    .sub{color:var(--muted); font-size:12px; margin-bottom:12px; line-height:1.35}
    .grid{display:grid; grid-template-columns: 420px 1fr; gap:12px; align-items:start;}
    @media (max-width: 980px){ .grid{grid-template-columns: 1fr} }

    .card{
      background:rgba(17,28,51,.9);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .card h2{
      margin:0 0 8px;
      font-size:14px; color:#e5e7eb;
      display:flex; align-items:center; gap:8px;
    }
    .row{
      display:grid;
      grid-template-columns: 150px 1fr 86px;
      gap:10px;
      align-items:center;
      margin:8px 0;
    }
    .row .lbl{font-size:12px; color:var(--muted)}
    input[type="range"]{width:100%}
    input[type="number"], select{
      width:100%;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(15,23,42,.9);
      color:var(--text);
      outline:none;
    }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}

    .kpis{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;}
    .kpi{
      border:1px dashed rgba(148,163,184,.35);
      border-radius:12px;
      padding:10px;
      background:rgba(15,23,42,.35);
    }
    .kpi small{display:block; color:var(--muted); margin-bottom:6px}
    .kpi .v{font-size:13px; font-weight:700}

    .btnrow{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    button{
      border:1px solid rgba(59,130,246,.35);
      background:linear-gradient(135deg,#2563eb,#3b82f6);
      color:white; font-weight:700;
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      flex:1;
      min-width:160px;
      touch-action: manipulation;
    }
    button.secondary{
      border:1px solid rgba(148,163,184,.35);
      background:rgba(15,23,42,.6);
      color:var(--text);
      font-weight:700;
    }
    button.danger{
      border:1px solid rgba(239,68,68,.35);
      background:linear-gradient(135deg,#b91c1c,#ef4444);
    }

    .note{font-size:12px; color:var(--muted); margin-top:10px; line-height:1.35;}
    .status{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(15,23,42,.35);
      font-size:12px;
      line-height:1.35;
    }

    .vizgrid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px;}
    @media (max-width: 1120px){ .vizgrid3{grid-template-columns:1fr} }

    canvas{
      width:100%;
      height:auto;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(15,23,42,.35);
    }

    .tight{margin-top:6px}
    .smallrow{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:6px;}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--line); background:rgba(15,23,42,.35);
      font-size:12px; color:var(--muted);
    }
    .dot{width:9px;height:9px;border-radius:999px;background:var(--muted)}
    .dot.good{background:var(--good)}
    .dot.bad{background:var(--bad)}
    .dot.warn{background:var(--warn)}
    .kbd{padding:2px 6px;border:1px solid var(--line);border-radius:8px;background:rgba(15,23,42,.4);font-family:ui-monospace,monospace}
  </style>
</head>
<body>
  <h1>Finite Disk + Yukawa: Threshold, Robust Confinement, and Constrained Minimization</h1>
  <div class="sub">
    We normalize the source so <span class="mono">a(z0)=g</span>. Then
    <span class="mono">a(z)/g = Φ(z) = G(z)/G(z0)</span> and
    <span class="mono">a'(z) = g Φ'(z)</span>.
    Robust confinement gates are <span class="kbd">directional</span> (RC1), <span class="kbd">monotone</span> (RC2), and <span class="kbd">stiffness</span> (RC3).
  </div>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <h2>1) Parameters</h2>

      <div class="row">
        <div class="lbl">Disk radius R (m)</div>
        <input id="R" type="range" min="0.05" max="2.0" step="0.01" value="0.25">
        <div class="mono" id="R_v"></div>
      </div>
      <div class="row">
        <div class="lbl">Thickness h (m)</div>
        <input id="h" type="range" min="0.001" max="0.20" step="0.001" value="0.02">
        <div class="mono" id="h_v"></div>
      </div>
      <div class="row">
        <div class="lbl">Standoff z₀ (m)</div>
        <input id="z0" type="range" min="0.01" max="2.0" step="0.01" value="0.10">
        <div class="mono" id="z0_v"></div>
      </div>
      <div class="row">
        <div class="lbl">Screening m (1/m)</div>
        <input id="m" type="range" min="0.0" max="10.0" step="0.05" value="1.00">
        <div class="mono" id="m_v"></div>
      </div>

      <div class="row">
        <div class="lbl">η_net (0..1)</div>
        <input id="eta" type="range" min="0.05" max="1.00" step="0.01" value="0.65">
        <div class="mono" id="eta_v"></div>
      </div>
      <div class="row">
        <div class="lbl">λ (m/J)</div>
        <input id="lam" type="range" min="0.001" max="10.0" step="0.001" value="1.000">
        <div class="mono" id="lam_v"></div>
      </div>
      <div class="row">
        <div class="lbl">β (m²/s²)</div>
        <input id="beta" type="range" min="0.001" max="10.0" step="0.001" value="0.100">
        <div class="mono" id="beta_v"></div>
      </div>
      <div class="row">
        <div class="lbl">τ (s)</div>
        <input id="tau" type="range" min="0.01" max="30.0" step="0.01" value="1.00">
        <div class="mono" id="tau_v"></div>
      </div>

      <div class="row">
        <div class="lbl">Profile (viz)</div>
        <select id="profile">
          <option value="uniform">Uniform disk ρc</option>
          <option value="gaussian">Gaussian ρc(r)</option>
        </select>
        <div></div>
      </div>

      <div class="kpis">
        <div class="kpi">
          <small>G(z₀,R,m)</small>
          <div class="mono v" id="G_v">—</div>
        </div>
        <div class="kpi">
          <small>ρc,req (J/m³)</small>
          <div class="mono v" id="rho_v">—</div>
        </div>
        <div class="kpi">
          <small>V = πR²h (m³)</small>
          <div class="mono v" id="V_v">—</div>
        </div>
        <div class="kpi">
          <small>Pin ≈ ρc V / τ (W)</small>
          <div class="mono v" id="P_v">—</div>
        </div>
      </div>

      <hr class="tight" style="border:0;border-top:1px solid var(--line);margin:12px 0;">

      <h2>2) Baseline constraints</h2>

      <div class="smallrow">
        <div>
          <div class="lbl">z_clear (m)</div>
          <input id="zClear" type="number" step="0.01" value="0.05">
        </div>
        <div>
          <div class="lbl">A_max = πR² (m²)</div>
          <input id="Amax" type="number" step="0.01" value="2.00">
        </div>
      </div>

      <div class="smallrow">
        <div>
          <div class="lbl">V_max = πR²h (m³)</div>
          <input id="Vmax" type="number" step="0.001" value="0.05">
        </div>
        <div>
          <div class="lbl">P_max (W)</div>
          <input id="Pmax" type="number" step="1" value="1e9">
        </div>
      </div>

      <div class="smallrow">
        <div>
          <div class="lbl">ρc_max (J/m³)</div>
          <input id="rhomax" type="number" step="1" value="1e12">
        </div>
        <div>
          <div class="lbl">Use caps</div>
          <select id="useCaps">
            <option value="yes" selected>Yes (enforce P_max & ρc_max)</option>
            <option value="no">No (ignore P_max & ρc_max)</option>
          </select>
        </div>
      </div>

      <hr class="tight" style="border:0;border-top:1px solid var(--line);margin:12px 0;">

      <h2>3) Robust confinement (Trap hardening)</h2>

      <div class="smallrow">
        <div>
          <div class="lbl">Enable robust gate</div>
          <select id="rcEnable">
            <option value="yes" selected>Yes (hard feasibility)</option>
            <option value="no">No (ignore trap hardening)</option>
          </select>
        </div>
        <div>
          <div class="lbl">Band samples (N)</div>
          <input id="rcSamples" type="number" step="1" value="81">
        </div>
      </div>

      <div class="smallrow">
        <div>
          <div class="lbl">Δz (m) — capture half-width</div>
          <input id="deltaZ" type="number" step="0.001" value="0.02">
        </div>
        <div>
          <div class="lbl">ε — directional margin</div>
          <input id="epsBand" type="number" step="0.001" value="0.02">
        </div>
      </div>

      <!-- NEW: RC1 exclusion gap -->
      <div class="smallrow">
        <div>
          <div class="lbl">gapZ (m) — RC1 exclusion around z0</div>
          <input id="gapZ" type="number" step="0.0005" value="0.004">
        </div>
        <div>
          <div class="lbl">Tip</div>
          <div class="note" style="margin:0">Use 0.002–0.006 for ε=0.01–0.02.</div>
        </div>
      </div>

      <div class="smallrow">
        <div>
          <div class="lbl">κ_min (s⁻²) — stiffness floor</div>
          <input id="kappaMin" type="number" step="1" value="30">
        </div>
        <div>
          <div class="lbl">Auto-set for current config</div>
          <button id="rcAuto" class="secondary" type="button" style="min-width:auto">Apply suggested</button>
        </div>
      </div>

      <div class="note">
        RC1 (directional): enforce <span class="mono">Φ(z&lt;z0-gapZ) ≥ 1+ε</span> and <span class="mono">Φ(z&gt;z0+gapZ) ≤ 1−ε</span> over the band.<br>
        RC2 (monotone): enforce <span class="mono">max Φ'(z) &lt; 0</span> over the band.<br>
        RC3 (stiffness): enforce <span class="mono">min |a'(z)| ≥ κ_min</span> over the band, where <span class="mono">a'(z)=g Φ'(z)</span>.
      </div>

      <div class="status" id="feas">
        <span class="pill"><span class="dot" id="dotFeas"></span> Feasibility: <span id="feasTxt">—</span></span>
        <div class="mono" id="whyTxt" style="margin-top:8px; white-space:pre-wrap;">—</div>
      </div>

      <hr class="tight" style="border:0;border-top:1px solid var(--line);margin:12px 0;">

      <h2>4) Constrained optimization</h2>

      <div class="smallrow">
        <div>
          <div class="lbl">Objective</div>
          <select id="obj">
            <option value="minPin" selected>Minimize Pin</option>
            <option value="minRho">Minimize ρc,req</option>
            <option value="maxTrapWorst">Maximize worst-case stiffness (band)</option>
            <option value="weighted">Weighted log objective</option>
          </select>
        </div>
        <div>
          <div class="lbl">Random iterations</div>
          <input id="randIters" type="number" step="1000" value="30000">
        </div>
      </div>

      <div class="smallrow">
        <div>
          <div class="lbl">wP (weighted)</div>
          <input id="wP" type="number" step="0.1" value="1.0">
        </div>
        <div>
          <div class="lbl">wρ (weighted)</div>
          <input id="wR" type="number" step="0.1" value="0.0">
        </div>
      </div>

      <div class="smallrow">
        <div>
          <div class="lbl">wV (weighted)</div>
          <input id="wV" type="number" step="0.1" value="0.0">
        </div>
        <div>
          <div class="lbl">Grid resolution</div>
          <select id="gridPreset">
            <option value="fast">Fast</option>
            <option value="med" selected>Medium</option>
            <option value="deep">Deep</option>
          </select>
        </div>
      </div>

      <div class="btnrow">
        <button id="optApply">Optimize & Apply</button>
        <button id="optOnly" class="secondary">Optimize (no apply)</button>
        <button id="reset" class="danger">Reset defaults</button>
      </div>

      <div class="status" id="bestBox">
        <div class="pill"><span class="dot" id="dotBest"></span> Best feasible: <span id="bestTxt">—</span></div>
        <div class="mono" id="bestMono" style="margin-top:8px; white-space:pre-wrap;">—</div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <h2>5) Visualizations</h2>
      <div class="vizgrid3">
        <div>
          <div class="sub">Coherence density map ρc(x,y) (normalized profile)</div>
          <canvas id="map" width="520" height="520"></canvas>
        </div>
        <div>
          <div class="sub">On-axis: a(z) with ρc set so a(z0)=g</div>
          <canvas id="plot" width="520" height="520"></canvas>
        </div>
        <div>
          <div class="sub">Trap diagnostics across band: Φ(z) and Φ′(z)</div>
          <canvas id="trap" width="520" height="520"></canvas>
          <div class="note" style="margin-top:8px">
            Blue: Φ(z). Green dashed: 1±ε thresholds. Orange: z0. <br>
            Purple: Φ′(z). Red dashed: 0 (must stay &lt;0). Cyan dashed: ±κ_min/g on Φ′ scale. Grey shade: gapZ region.
          </div>
        </div>
      </div>

      <!-- Time simulation block (damping + drive) -->
      <div style="margin-top:12px">
        <div class="sub">Time simulation: z(t) with viscous drag and optional ρc modulation</div>

        <!-- UPDATED: add critical damping helper button -->
        <div class="smallrow">
          <div>
            <div class="lbl">Drag c (s⁻¹)</div>
            <input id="dragC" type="number" step="0.1" value="2.0">
          </div>
          <div>
            <div class="lbl">Critical damping helper</div>
            <button id="setCrit" class="secondary" type="button" style="width:100%;min-width:auto">Set c ≈ 2ω₀</button>
          </div>
        </div>

        <div class="smallrow">
          <div>
            <div class="lbl">Initial offset Δz (m)</div>
            <input id="zKick" type="number" step="0.001" value="0.005">
          </div>
          <div>
            <div class="lbl">Duration T (s)</div>
            <input id="simT" type="number" step="0.1" value="8.0">
          </div>
        </div>

        <div class="smallrow">
          <div>
            <div class="lbl">Time step dt (s)</div>
            <input id="simDt" type="number" step="0.0005" value="0.002">
          </div>
          <div>
            <div class="lbl">Drive amp A (fraction; 0.05 = 5%)</div>
            <input id="driveA" type="number" step="0.001" value="0.05">
          </div>
        </div>

        <div class="smallrow">
          <div>
            <div class="lbl">Drive freq f (Hz)</div>
            <input id="driveF" type="number" step="0.1" value="1.0">
          </div>
          <div>
            <div class="lbl">Drive phase φ (rad)</div>
            <input id="drivePhi" type="number" step="0.1" value="0.0">
          </div>
        </div>

        <div class="smallrow">
          <div>
            <div class="lbl">Enable drive</div>
            <select id="driveOn">
              <option value="yes" selected>Yes</option>
              <option value="no">No</option>
            </select>
          </div>
          <div>
            <div class="lbl"> </div>
            <div class="note" style="margin:0">Drive is ρc modulation: a(z,t)=g(1+u(t))Φ(z).</div>
          </div>
        </div>

        <div class="btnrow">
          <button id="runSim" class="secondary" type="button">Run time sim</button>
        </div>

        <canvas id="sim" width="1560" height="420"></canvas>
        <div class="note">
          Blue: z(t). Orange dashed: z0. Green dashed: z0±Δz band (robust half-width).
        </div>

        <!-- NEW: sim stats -->
        <div class="status" id="simStats" style="margin-top:10px">
          <span class="pill"><span class="dot" id="dotSim"></span> Sim stats</span>
          <div class="mono" id="simStatsTxt" style="margin-top:8px; white-space:pre-wrap;">—</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const g = 9.81;
  const el = (id) => document.getElementById(id);

  const fmt = (x, n=4) => (Number.isFinite(x) ? x.toFixed(n) : "—");
  const fmtAuto = (x) => {
    if(!Number.isFinite(x)) return "—";
    if (Math.abs(x) < 1e6) return x.toFixed(4);
    return x.toExponential(3);
  };

  // ---------------------------
  // Geometry: disk + Yukawa
  // ---------------------------
  function G(z, R, m){
    const a = Math.max(1e-12, z);
    const s = Math.sqrt(z*z + R*R);
    const term1 = Math.exp(-m*a);
    const term2 = (z/s) * Math.exp(-m*s);
    return Math.max(1e-15, 0.5*(term1 - term2));
  }

  function dGdz(z, R, m){
    const a = Math.max(1e-12, z);
    const s = Math.sqrt(z*z + R*R);
    const f1p = -m * Math.exp(-m*a);

    const expms = Math.exp(-m*s);
    const uPrime = (R*R) / (s*s*s);     // d/dz(z/s)
    const vPrimeFactor = -m * (z/s);    // (1/exp)*d/dz(exp)
    const f2p = expms * (uPrime + (z/s)*vPrimeFactor);
    return 0.5*(f1p - f2p);
  }

  function Phi(z, x){ return G(z, x.R, x.m) / G(x.z0, x.R, x.m); }
  function dPhidz(z, x){ return dGdz(z, x.R, x.m) / G(x.z0, x.R, x.m); }

  // ---------------------------
  // Threshold & resources
  // ---------------------------
  function rhoReq(x){
    const GG = G(x.z0, x.R, x.m);
    const denom =
      Math.max(1e-15,x.beta) *
      Math.max(1e-15,x.eta) *
      Math.max(1e-15,x.lam) *
      Math.max(1e-15,x.h)   *
      GG;
    return g / denom;
  }

  function volume(x){ return Math.PI * x.R*x.R * x.h; }
  function area(x){ return Math.PI * x.R*x.R; }
  function pin(x){ return rhoReq(x) * volume(x) / Math.max(1e-15,x.tau); }

  function aOfZ(z, x){ return g * Phi(z, x); }
  function aPrimeOfZ(z, x){ return g * dPhidz(z, x); } // s^-2

  // ---------------------------
  // UI state
  // ---------------------------
  function currentX(){
    return {
      R: parseFloat(el("R").value),
      h: parseFloat(el("h").value),
      z0: parseFloat(el("z0").value),
      m: parseFloat(el("m").value),
      eta: parseFloat(el("eta").value),
      lam: parseFloat(el("lam").value),
      beta: parseFloat(el("beta").value),
      tau: parseFloat(el("tau").value),
    };
  }

  function currentConstraints(){
    const useCaps = el("useCaps").value === "yes";
    return {
      zClear: parseFloat(el("zClear").value),
      Amax: parseFloat(el("Amax").value),
      Vmax: parseFloat(el("Vmax").value),
      Pmax: useCaps ? parseFloat(el("Pmax").value) : Infinity,
      rhoMax: useCaps ? parseFloat(el("rhomax").value) : Infinity,
      useCaps,
    };
  }

  function currentRobust(){
    return {
      enabled: el("rcEnable").value === "yes",
      deltaZ: parseFloat(el("deltaZ").value),
      epsBand: parseFloat(el("epsBand").value),
      gapZ: parseFloat(el("gapZ")?.value || "0.004"),
      kappaMin: parseFloat(el("kappaMin").value),
      samples: Math.max(11, Math.floor(parseFloat(el("rcSamples").value) || 81))
    };
  }

  // ---------------------------
  // Robust confinement check (RC1 uses gapZ)
  // ---------------------------
  function robustConfinementCheck(x, rb){
    const dz = Math.max(0, rb.deltaZ);
    const eps = Math.max(0, rb.epsBand);
    const gap = Math.max(0, rb.gapZ || 0);
    const kMin = Math.max(0, rb.kappaMin);

    const zLo = Math.max(1e-4, x.z0 - dz);
    const zHi = x.z0 + dz;
    const N = rb.samples;

    let minPhiBelow = +Infinity;
    let maxPhiAbove = -Infinity;
    let maxPhiPrime = -Infinity;
    let minAbsAPrime = +Infinity;

    for(let i=0;i<N;i++){
      const z = zLo + (zHi - zLo) * (i/(N-1));
      const phi = Phi(z, x);
      const phip = dPhidz(z, x);

      // RC1 enforced only outside [z0-gap, z0+gap]
      if (z < x.z0 - gap) minPhiBelow = Math.min(minPhiBelow, phi);
      if (z > x.z0 + gap) maxPhiAbove = Math.max(maxPhiAbove, phi);

      // RC2: monotone restoring slope
      maxPhiPrime = Math.max(maxPhiPrime, phip);

      // RC3: stiffness floor (a' = g * Phi')
      const apr = g * phip;
      minAbsAPrime = Math.min(minAbsAPrime, Math.abs(apr));
    }

    const reasons = [];
    if (minPhiBelow !== +Infinity && !(minPhiBelow >= 1 + eps)){
      reasons.push(`RC1 fail: min Φ below (outside gap) = ${minPhiBelow.toFixed(4)} < ${(1+eps).toFixed(4)}`);
    }
    if (maxPhiAbove !== -Infinity && !(maxPhiAbove <= 1 - eps)){
      reasons.push(`RC1 fail: max Φ above (outside gap) = ${maxPhiAbove.toFixed(4)} > ${(1-eps).toFixed(4)}`);
    }
    if (!(maxPhiPrime < 0)){
      reasons.push(`RC2 fail: max Φ' in band = ${maxPhiPrime.toExponential(3)} (must be < 0)`);
    }
    if (!(minAbsAPrime >= kMin)){
      reasons.push(`RC3 fail: min |a'(z)| in band = ${minAbsAPrime.toFixed(3)} < κ_min=${kMin.toFixed(3)} s^-2`);
    }

    return {
      ok: reasons.length === 0,
      reasons,
      stats: { zLo, zHi, minPhiBelow, maxPhiAbove, maxPhiPrime, minAbsAPrime, gap }
    };
  }

  function worstCaseStiffness(x, rb){
    const dz = Math.max(0, rb.deltaZ);
    const zLo = Math.max(1e-4, x.z0 - dz);
    const zHi = x.z0 + dz;
    const N = rb.samples;

    let worst = +Infinity;
    for(let i=0;i<N;i++){
      const z = zLo + (zHi - zLo) * (i/(N-1));
      worst = Math.min(worst, Math.abs(aPrimeOfZ(z, x)));
    }
    return worst;
  }

  // ---------------------------
  // Feasibility + objectives
  // ---------------------------
  function feasibilityReasons(x, C, rb){
    const reasons = [];

    if (x.z0 < C.zClear) reasons.push(`z0 < z_clear  (${x.z0.toFixed(3)} < ${C.zClear.toFixed(3)})`);

    const A = area(x);
    const V = volume(x);
    const rho = rhoReq(x);
    const P = rho * V / Math.max(1e-15, x.tau);

    if (A > C.Amax) reasons.push(`Area πR² > A_max  (${A.toExponential(3)} > ${C.Amax.toExponential(3)})`);
    if (V > C.Vmax) reasons.push(`Volume πR²h > V_max  (${V.toExponential(3)} > ${C.Vmax.toExponential(3)})`);
    if (rho > C.rhoMax) reasons.push(`rho_req > rho_max  (${rho.toExponential(3)} > ${C.rhoMax.toExponential(3)})`);
    if (P > C.Pmax) reasons.push(`Pin > P_max  (${P.toExponential(3)} > ${C.Pmax.toExponential(3)})`);

    const GG = G(x.z0, x.R, x.m);
    if (!(GG > 0)) reasons.push(`G(z0,R,m) is nonpositive (check m,z0,R)`);

    if (rb.enabled){
      const rc = robustConfinementCheck(x, rb);
      if (!rc.ok) reasons.push(...rc.reasons);
    }

    return reasons;
  }

  function isFeasible(x, C, rb){ return feasibilityReasons(x, C, rb).length === 0; }

  function objective(x, kind, weights, rb){
    const rho = rhoReq(x);
    const P = rho * volume(x) / Math.max(1e-15,x.tau);
    const V = volume(x);

    if (kind === "minPin") return P;
    if (kind === "minRho") return rho;
    if (kind === "maxTrapWorst") return -worstCaseStiffness(x, rb);

    const wP = weights.wP, wR = weights.wR, wV = weights.wV;
    return wP*Math.log(Math.max(1e-30,P)) + wR*Math.log(Math.max(1e-30,rho)) + wV*Math.log(Math.max(1e-30,V));
  }

  // ---------------------------
  // Optimizer (grid + random)
  // ---------------------------
  function linspace(a,b,n){
    if(n<=1) return [a];
    const out = [];
    for(let i=0;i<n;i++) out.push(a + (b-a)*i/(n-1));
    return out;
  }
  function randUniform(a,b){ return a + Math.random()*(b-a); }

  function gridSettings(preset){
    if(preset==="fast") return {gridR:26, gridZ:26, gridM:18, gridH:14};
    if(preset==="deep") return {gridR:60, gridZ:60, gridM:40, gridH:24};
    return {gridR:40, gridZ:40, gridM:30, gridH:20};
  }

  function constrainedMinimize(bounds, C, rb, objectiveType, weights, preset, randIters){
    const gset = gridSettings(preset);
    let best = null;
    let bestJ = Infinity;

    const Rs = linspace(bounds.Rmin, bounds.Rmax, gset.gridR);
    const zs = linspace(bounds.z0min, bounds.z0max, gset.gridZ);
    const ms = linspace(bounds.mmin, bounds.mmax, gset.gridM);
    const hs = linspace(bounds.hmin, bounds.hmax, gset.gridH);

    for (const R of Rs){
      for (const z0 of zs){
        if (z0 < C.zClear) continue;
        for (const m of ms){
          for (const h of hs){
            const x = { R, z0, m, h, eta: bounds.etaFixed, lam: bounds.lamFixed, beta: bounds.betaFixed, tau: bounds.tauFixed };
            if (!isFeasible(x,C,rb)) continue;
            const J = objective(x, objectiveType, weights, rb);
            if (J < bestJ){ bestJ = J; best = {...x}; }
          }
        }
      }
    }

    const iters = Math.max(0, Math.floor(randIters));
    for (let i=0;i<iters;i++){
      const x = {
        R:  randUniform(bounds.Rmin, bounds.Rmax),
        z0: randUniform(Math.max(bounds.z0min, C.zClear), bounds.z0max),
        m:  randUniform(bounds.mmin, bounds.mmax),
        h:  randUniform(bounds.hmin, bounds.hmax),
        eta: bounds.etaFixed, lam: bounds.lamFixed, beta: bounds.betaFixed, tau: bounds.tauFixed
      };
      if (!isFeasible(x,C,rb)) continue;
      const J = objective(x, objectiveType, weights, rb);
      if (J < bestJ){ bestJ = J; best = {...x}; }
    }

    if (best){
      best.G = G(best.z0,best.R,best.m);
      best.rho = rhoReq(best);
      best.V = volume(best);
      best.A = area(best);
      best.P = pin(best);
      best.ap0 = aPrimeOfZ(best.z0, best);
      best.worstK = rb.enabled ? worstCaseStiffness(best, rb) : NaN;
      best.J = bestJ;
    }
    return best;
  }

  // ---------------------------
  // Visuals
  // ---------------------------
  function drawMap(ctx, Rm, profile){
    const w = ctx.canvas.width, h = ctx.canvas.height;
    const img = ctx.createImageData(w,h);
    const cx = w/2, cy = h/2;
    const span = 2.2*Rm;
    const pxToM = span / w;
    const sigma = 0.35*Rm;

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const dx = (x-cx)*pxToM;
        const dy = (y-cy)*pxToM;
        const r = Math.sqrt(dx*dx+dy*dy);
        let val = 0;
        if(profile==="uniform"){
          val = (r<=Rm) ? 1 : 0;
        }else{
          val = (r<=Rm) ? Math.exp(-(r*r)/(2*sigma*sigma)) : 0;
        }
        const i = (y*w + x)*4;
        const c = Math.floor(255*val);
        img.data[i+0]=c; img.data[i+1]=c; img.data[i+2]=c; img.data[i+3]=255;
      }
    }
    ctx.putImageData(img,0,0);

    ctx.strokeStyle="rgba(203,213,225,.9)";
    ctx.lineWidth=2;
    ctx.beginPath();
    const Rp = Rm/pxToM;
    ctx.arc(cx,cy,Rp,0,Math.PI*2);
    ctx.stroke();
  }

  function drawPlotA(ctx, x){
    const w = ctx.canvas.width, h = ctx.canvas.height;
    ctx.clearRect(0,0,w,h);

    ctx.strokeStyle="rgba(203,213,225,.55)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(60,30); ctx.lineTo(60,h-50); ctx.lineTo(w-25,h-50);
    ctx.stroke();

    const zMax = Math.max(0.5, 2.0*x.R);
    const zMin = 0.01;
    const N = 240;

    let vmax = 0;
    const vals = [];
    for(let i=0;i<N;i++){
      const z = zMin + (zMax-zMin)*(i/(N-1));
      const az = aOfZ(z, x);
      vmax = Math.max(vmax, az);
      vals.push({z,az});
    }
    vmax = Math.max(vmax, 1e-12);

    ctx.strokeStyle="rgba(59,130,246,.95)";
    ctx.lineWidth=2;
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const px = 60 + (w-85)*(vals[i].z - zMin)/(zMax-zMin);
      const py = (h-50) - (h-90)*(vals[i].az / vmax);
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();

    const gy = (h-50) - (h-90)*(g / vmax);
    if (g < vmax){
      ctx.setLineDash([6,6]);
      ctx.strokeStyle="rgba(16,185,129,.9)";
      ctx.beginPath(); ctx.moveTo(60,gy); ctx.lineTo(w-25,gy); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle="rgba(16,185,129,.95)";
      ctx.font="12px system-ui";
      ctx.fillText("g", 66, gy-6);
    }

    const xz0 = 60 + (w-85)*(x.z0 - zMin)/(zMax-zMin);
    ctx.strokeStyle="rgba(245,158,11,.9)";
    ctx.beginPath(); ctx.moveTo(xz0,30); ctx.lineTo(xz0,h-50); ctx.stroke();
    ctx.fillStyle="rgba(245,158,11,.95)";
    ctx.fillText("z0", xz0+4, 44);

    ctx.fillStyle="rgba(203,213,225,.9)";
    ctx.font="13px system-ui";
    ctx.fillText("z (m)", w/2, h-14);
    ctx.save();
    ctx.translate(18,h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText("a(z) (scaled)", 0, 0);
    ctx.restore();

    ctx.font="12px ui-monospace, monospace";
    ctx.fillStyle="rgba(203,213,225,.9)";
    const ap0 = aPrimeOfZ(x.z0, x);
    ctx.fillText(`a'(z0) ≈ ${ap0.toFixed(3)} s^-2`, 70, 44);
  }

  function drawTrapDiagnostics(ctx, x, rb){
    const w = ctx.canvas.width, h = ctx.canvas.height;
    ctx.clearRect(0,0,w,h);

    const dz = Math.max(0, rb.deltaZ);
    const zLo = Math.max(1e-4, x.z0 - dz);
    const zHi = x.z0 + dz;

    const padL = 64, padR = 24, padT = 24, padB = 38;
    const mid = Math.floor((h - padT - padB) * 0.52) + padT;

    // background grid
    ctx.strokeStyle = "rgba(203,213,225,.12)";
    ctx.lineWidth = 1;
    for(let i=0;i<=6;i++){
      const yy = padT + (h-padT-padB) * i/6;
      ctx.beginPath(); ctx.moveTo(padL, yy); ctx.lineTo(w-padR, yy); ctx.stroke();
    }
    for(let i=0;i<=6;i++){
      const xx = padL + (w-padL-padR) * i/6;
      ctx.beginPath(); ctx.moveTo(xx, padT); ctx.lineTo(xx, h-padB); ctx.stroke();
    }

    // divider
    ctx.strokeStyle = "rgba(203,213,225,.25)";
    ctx.beginPath(); ctx.moveTo(padL, mid); ctx.lineTo(w-padR, mid); ctx.stroke();

    const N = Math.max(31, rb.samples);
    const zs = [];
    const phis = [];
    const phips = [];
    let phiMin = +Infinity, phiMax = -Infinity;
    let phipMin = +Infinity, phipMax = -Infinity;

    for(let i=0;i<N;i++){
      const z = zLo + (zHi - zLo) * (i/(N-1));
      const phi = Phi(z, x);
      const phip = dPhidz(z, x);
      zs.push(z); phis.push(phi); phips.push(phip);

      phiMin = Math.min(phiMin, phi);
      phiMax = Math.max(phiMax, phi);
      phipMin = Math.min(phipMin, phip);
      phipMax = Math.max(phipMax, phip);
    }

    // Include thresholds in plot range
    const eps = Math.max(0, rb.epsBand);
    phiMin = Math.min(phiMin, 1 - eps);
    phiMax = Math.max(phiMax, 1 + eps);

    const kPhi = (Math.max(0, rb.kappaMin) / g);
    phipMin = Math.min(phipMin, -kPhi, 0);
    phipMax = Math.max(phipMax, +kPhi, 0);

    // Helpers
    const xToPx = (z) => padL + (w-padL-padR) * ((z - zLo) / Math.max(1e-12, (zHi - zLo)));
    const yPhiToPx = (phi) => {
      const topH = (mid - padT) - 10;
      const t = (phi - phiMin) / Math.max(1e-12, (phiMax - phiMin));
      return (mid - 10) - topH * t;
    };
    const yPhipToPx = (phip) => {
      const botTop = mid + 10;
      const botH = (h - padB) - botTop;
      const t = (phip - phipMin) / Math.max(1e-12, (phipMax - phipMin));
      return (h - padB) - botH * t;
    };

    // NEW: Shade excluded RC1 gap region around z0
    const gap = Math.max(0, rb.gapZ || 0);
    if (gap > 0){
      const xL = xToPx(Math.max(zLo, x.z0 - gap));
      const xR = xToPx(Math.min(zHi, x.z0 + gap));
      ctx.fillStyle = "rgba(148,163,184,.10)";
      ctx.fillRect(xL, padT, Math.max(0, xR - xL), (h - padB - padT));
    }

    // Threshold lines for Φ: 1±eps
    ctx.setLineDash([6,6]);
    ctx.strokeStyle = "rgba(16,185,129,.85)";
    ctx.lineWidth = 1.5;
    const yUp = yPhiToPx(1+eps);
    const yDn = yPhiToPx(1-eps);
    ctx.beginPath(); ctx.moveTo(padL, yUp); ctx.lineTo(w-padR, yUp); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padL, yDn); ctx.lineTo(w-padR, yDn); ctx.stroke();

    // Φ': 0 (red) and ±kPhi (cyan)
    ctx.strokeStyle = "rgba(239,68,68,.85)";
    const y0 = yPhipToPx(0);
    ctx.beginPath(); ctx.moveTo(padL, y0); ctx.lineTo(w-padR, y0); ctx.stroke();

    ctx.strokeStyle = "rgba(34,211,238,.85)";
    const yKp = yPhipToPx(+kPhi);
    const yKm = yPhipToPx(-kPhi);
    ctx.beginPath(); ctx.moveTo(padL, yKp); ctx.lineTo(w-padR, yKp); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padL, yKm); ctx.lineTo(w-padR, yKm); ctx.stroke();
    ctx.setLineDash([]);

    // Φ(z)
    ctx.strokeStyle = "rgba(59,130,246,.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const px = xToPx(zs[i]);
      const py = yPhiToPx(phis[i]);
      i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
    }
    ctx.stroke();

    // Φ'(z)
    ctx.strokeStyle = "rgba(168,85,247,.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const px = xToPx(zs[i]);
      const py = yPhipToPx(phips[i]);
      i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
    }
    ctx.stroke();

    // z0 marker
    const xz0 = xToPx(x.z0);
    ctx.strokeStyle="rgba(245,158,11,.95)";
    ctx.lineWidth=1.8;
    ctx.beginPath(); ctx.moveTo(xz0, padT); ctx.lineTo(xz0, h-padB); ctx.stroke();

    // Labels
    ctx.fillStyle = "rgba(203,213,225,.9)";
    ctx.font = "12px system-ui";
    ctx.fillText("z (m)", (padL + (w-padR))/2, h-12);

    ctx.font = "12px ui-monospace, monospace";
    ctx.fillText("Φ(z)", padL, padT+12);
    ctx.fillText("Φ'(z)", padL, mid+22);

    // tick labels
    ctx.fillStyle = "rgba(203,213,225,.75)";
    ctx.font = "11px ui-monospace, monospace";
    ctx.fillText(phiMax.toFixed(3), 8, padT+12);
    ctx.fillText(phiMin.toFixed(3), 8, mid-12);
    ctx.fillText(phipMax.toExponential(2), 8, mid+18);
    ctx.fillText(phipMin.toExponential(2), 8, h-padB);

    // Mark violations (still shows red/cyan for RC2/RC3; green for RC1 outside gap)
    if (rb.enabled){
      const epsOkLow = 1+eps, epsOkHigh = 1-eps;
      for(let i=0;i<N;i++){
        const z = zs[i];
        const phi = phis[i];
        const phip = phips[i];

        const outsideGap = (z < x.z0 - gap) || (z > x.z0 + gap);
        const bad1 = outsideGap && ((z < x.z0 && phi < epsOkLow) || (z > x.z0 && phi > epsOkHigh));
        const bad2 = (phip >= 0);
        const bad3 = (Math.abs(g*phip) < rb.kappaMin);

        if (bad1){
          ctx.fillStyle = "rgba(16,185,129,.95)";
          ctx.fillRect(xToPx(z)-2, yPhiToPx(phi)-2, 4, 4);
        }
        if (bad2 || bad3){
          ctx.fillStyle = bad2 ? "rgba(239,68,68,.95)" : "rgba(34,211,238,.95)";
          ctx.fillRect(xToPx(z)-2, yPhipToPx(phip)-2, 4, 4);
        }
      }
    }
  }

  // ---------------------------
  // Time simulation (RK4 + viscous drag + optional modulation)
  // ---------------------------
  function simulateTimeSeries(x, rb, c, zKick, T, dt, drive){
    let z = x.z0 + zKick, v = 0;
    const steps = Math.max(10, Math.floor(T / dt));
    const out = new Array(steps);

    const driveOn = !!drive?.on;
    const A = Math.max(0, drive?.A || 0);
    const f = Math.max(0, drive?.f || 0);
    const phi = drive?.phi || 0;
    const twoPiF = 2*Math.PI*f;

    const u = (t) => driveOn ? (A * Math.sin(twoPiF*t + phi)) : 0;

    // z¨ = g( (1+u(t))*Phi(z) - 1 ) - c z˙
    const acc = (t, zz, vv) => (g * ((1 + u(t)) * Phi(zz, x) - 1)) - c * vv;

    for (let i=0; i<steps; i++){
      const t = i * dt;
      out[i] = { t, z, v, u: u(t) };

      // RK4
      const k1z = v, k1v = acc(t, z, v);
      const z2 = z + 0.5*dt*k1z, v2 = v + 0.5*dt*k1v;
      const k2z = v2, k2v = acc(t + 0.5*dt, z2, v2);
      const z3 = z + 0.5*dt*k2z, v3 = v + 0.5*dt*k2v;
      const k3z = v3, k3v = acc(t + 0.5*dt, z3, v3);
      const z4 = z + dt*k3z, v4 = v + dt*k3v;
      const k4z = v4, k4v = acc(t + dt, z4, v4);

      z += (dt/6) * (k1z + 2*k2z + 2*k3z + k4z);
      v += (dt/6) * (k1v + 2*k2v + 2*k3v + k4v);

      if (z < 1e-4){ z = 1e-4; v = 0; }
    }
    return out;
  }

  function computeSimStats(data, x, rb){
    const dz = Math.max(0, rb.deltaZ);
    const zLo = x.z0 - dz, zHi = x.z0 + dz;

    let zMin = +Infinity, zMax = -Infinity;
    let maxAbsDev = 0;
    let outside = 0;

    for (const p of data){
      zMin = Math.min(zMin, p.z);
      zMax = Math.max(zMax, p.z);
      maxAbsDev = Math.max(maxAbsDev, Math.abs(p.z - x.z0));
      if (p.z < zLo || p.z > zHi) outside++;
    }

    const p2p = zMax - zMin;
    const fracOutside = outside / Math.max(1, data.length);
    return { zMin, zMax, p2p, maxAbsDev, fracOutside };
  }

  function drawSim(ctx, data, x, rb){
    const w = ctx.canvas.width, h = ctx.canvas.height;
    ctx.clearRect(0,0,w,h);

    const padL = 70, padR = 20, padT = 18, padB = 38;
    const tMin = data[0].t, tMax = data[data.length-1].t;

    let zMin = +Infinity, zMax = -Infinity;
    for (const p of data){ zMin = Math.min(zMin, p.z); zMax = Math.max(zMax, p.z); }
    const zPad = 0.08 * Math.max(1e-6, (zMax - zMin));
    zMin -= zPad; zMax += zPad;

    const xToPx = (t) => padL + (w-padL-padR) * ((t - tMin) / Math.max(1e-12, (tMax - tMin)));
    const yToPx = (z) => (h-padB) - (h-padT-padB) * ((z - zMin) / Math.max(1e-12, (zMax - zMin)));

    ctx.strokeStyle="rgba(203,213,225,.35)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(padL,padT); ctx.lineTo(padL,h-padB); ctx.lineTo(w-padR,h-padB);
    ctx.stroke();

    // z0 and band
    const dz = Math.max(0, rb.deltaZ);
    ctx.setLineDash([6,6]);
    ctx.strokeStyle="rgba(245,158,11,.9)";
    const yZ0 = yToPx(x.z0);
    ctx.beginPath(); ctx.moveTo(padL,yZ0); ctx.lineTo(w-padR,yZ0); ctx.stroke();

    ctx.strokeStyle="rgba(16,185,129,.75)";
    ctx.beginPath(); ctx.moveTo(padL,yToPx(x.z0+dz)); ctx.lineTo(w-padR,yToPx(x.z0+dz)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padL,yToPx(x.z0-dz)); ctx.lineTo(w-padR,yToPx(x.z0-dz)); ctx.stroke();
    ctx.setLineDash([]);

    // z(t)
    ctx.strokeStyle="rgba(59,130,246,.95)";
    ctx.lineWidth=2;
    ctx.beginPath();
    for (let i=0;i<data.length;i++){
      const px = xToPx(data[i].t), py = yToPx(data[i].z);
      i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
    }
    ctx.stroke();

    // Labels
    ctx.fillStyle="rgba(203,213,225,.9)";
    ctx.font="12px system-ui";
    ctx.fillText("t (s)", (padL + w-padR)/2, h-10);
    ctx.save();
    ctx.translate(18, (padT + h-padB)/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText("z (m)", 0, 0);
    ctx.restore();

    ctx.font="12px ui-monospace, monospace";
    ctx.fillText(`z range: [${zMin.toFixed(4)}, ${zMax.toFixed(4)}] | z0=${x.z0.toFixed(4)}`, padL, padT+12);
  }

  function omega0Estimate(x){
    const ap0 = aPrimeOfZ(x.z0, x);
    if (!(ap0 < 0)) return NaN;
    return Math.sqrt(-ap0); // rad/s
  }

  // ---------------------------
  // UI update
  // ---------------------------
  function updateFeasibility(x){
    const C = currentConstraints();
    const rb = currentRobust();
    const rc = rb.enabled ? robustConfinementCheck(x, rb) : null;

    const reasons = feasibilityReasons(x,C,rb);
    const ok = reasons.length===0;

    el("feasTxt").textContent = ok
      ? (rb.enabled ? (rc.ok ? "FEASIBLE | ROBUST PASS" : "FEASIBLE | ROBUST FAIL") : "FEASIBLE")
      : "INFEASIBLE";

    el("dotFeas").className = "dot " + (ok ? "good" : "bad");

    let extra = "";
    if (rb.enabled && rc){
      extra =
        `\n\nRobust stats (band):\n` +
        `z∈[${rc.stats.zLo.toFixed(3)}, ${rc.stats.zHi.toFixed(3)}] m\n` +
        `gapZ=${rc.stats.gap.toFixed(4)} m\n` +
        `min Φ below (outside gap) = ${rc.stats.minPhiBelow.toFixed(4)} (≥ ${(1+rb.epsBand).toFixed(4)})\n` +
        `max Φ above (outside gap) = ${rc.stats.maxPhiAbove.toFixed(4)} (≤ ${(1-rb.epsBand).toFixed(4)})\n` +
        `max Φ' = ${rc.stats.maxPhiPrime.toExponential(3)} (< 0)\n` +
        `min |a'| = ${rc.stats.minAbsAPrime.toFixed(3)} s^-2 (≥ κ_min=${rb.kappaMin.toFixed(3)})`;
    }

    el("whyTxt").textContent = ok
      ? "All active constraints satisfied." + extra
      : reasons.map(r => "- " + r).join("\n") + extra;
  }

  function update(){
    const x = currentX();
    const profile = el("profile").value;
    const rb = currentRobust();

    el("R_v").textContent = fmt(x.R,2);
    el("h_v").textContent = fmt(x.h,3);
    el("z0_v").textContent = fmt(x.z0,2);
    el("m_v").textContent = fmt(x.m,2);
    el("eta_v").textContent = fmt(x.eta,2);
    el("lam_v").textContent = fmt(x.lam,3);
    el("beta_v").textContent = fmt(x.beta,3);
    el("tau_v").textContent = fmt(x.tau,2);

    const GG = G(x.z0,x.R,x.m);
    const rho = rhoReq(x);
    const V = volume(x);
    const P = rho*V/Math.max(1e-15,x.tau);

    el("G_v").textContent = fmt(GG,6);
    el("rho_v").textContent = fmtAuto(rho);
    el("V_v").textContent = V.toExponential(3);
    el("P_v").textContent = fmtAuto(P);

    updateFeasibility(x);

    drawMap(el("map").getContext("2d"), x.R, profile);
    drawPlotA(el("plot").getContext("2d"), x);
    drawTrapDiagnostics(el("trap").getContext("2d"), x, rb);
  }

  function applyX(best){
    el("R").value = best.R.toFixed(2);
    el("h").value = best.h.toFixed(3);
    el("z0").value = best.z0.toFixed(2);
    el("m").value = best.m.toFixed(2);
    update();
  }

  function runOpt(apply){
    const C = currentConstraints();
    const rb = currentRobust();
    const cur = currentX();

    const bounds = {
      Rmin:0.05, Rmax:2.0,
      hmin:0.001, hmax:0.20,
      z0min:0.01, z0max:2.0,
      mmin:0.0,  mmax:10.0,
      etaFixed:cur.eta, lamFixed:cur.lam, betaFixed:cur.beta, tauFixed:cur.tau
    };

    const objectiveType = el("obj").value;
    const weights = { wP: +el("wP").value, wR: +el("wR").value, wV: +el("wV").value };
    const preset = el("gridPreset").value;
    const randIters = +el("randIters").value;

    const best = constrainedMinimize(bounds, C, rb, objectiveType, weights, preset, randIters);

    if (!best){
      el("dotBest").className = "dot bad";
      el("bestTxt").textContent = "NONE";
      el("bestMono").textContent =
        "No feasible design found under current constraints.\n" +
        "Try increasing A_max/V_max, relaxing P_max or rho_max, lowering z_clear,\n" +
        "or temporarily disabling robust gate to diagnose.\n" +
        "Also try 'Deep' grid or more random iterations.";
      return;
    }

    el("dotBest").className = "dot good";
    el("bestTxt").textContent = "FOUND";

    const rbLine = rb.enabled ? `worst-case κ (band)=${best.worstK.toFixed(3)} s^-2\n` : "";
    el("bestMono").textContent =
      `R=${best.R.toFixed(3)} m, h=${best.h.toFixed(4)} m, z0=${best.z0.toFixed(3)} m, m=${best.m.toFixed(3)} 1/m\n` +
      `G=${best.G.toExponential(3)}\n` +
      `rho_req=${best.rho.toExponential(3)} J/m^3\n` +
      `A=πR^2=${best.A.toExponential(3)} m^2, V=πR^2h=${best.V.toExponential(3)} m^3\n` +
      `Pin=${best.P.toExponential(3)} W\n` +
      `a'(z0)=${best.ap0.toFixed(3)} s^-2\n` +
      rbLine +
      `Objective J=${Number.isFinite(best.J)? best.J.toExponential(3): best.J}`;

    if (apply) applyX(best);
  }

  function resetDefaults(){
    el("R").value=0.25;
    el("h").value=0.02;
    el("z0").value=0.10;
    el("m").value=1.00;
    el("eta").value=0.65;
    el("lam").value=1.000;
    el("beta").value=0.100;
    el("tau").value=1.00;

    el("zClear").value=0.05;
    el("Amax").value=2.00;
    el("Vmax").value=0.05;
    el("Pmax").value=1e9;
    el("rhomax").value=1e12;
    el("useCaps").value="yes";

    el("rcEnable").value="yes";
    el("deltaZ").value=0.02;
    el("epsBand").value=0.02;
    el("gapZ").value=0.004;
    el("kappaMin").value=30;
    el("rcSamples").value=81;

    el("obj").value="minPin";
    el("randIters").value=30000;
    el("wP").value=1.0;
    el("wR").value=0.0;
    el("wV").value=0.0;
    el("gridPreset").value="med";
    el("profile").value="uniform";

    el("dragC").value=2.0;
    el("zKick").value=0.005;
    el("simT").value=8.0;
    el("simDt").value=0.002;
    el("driveA").value=0.05;
    el("driveF").value=1.0;
    el("drivePhi").value=0.0;
    el("driveOn").value="yes";

    el("dotBest").className="dot";
    el("bestTxt").textContent="—";
    el("bestMono").textContent="—";

    el("dotSim").className="dot";
    el("simStatsTxt").textContent="—";

    update();
  }

  function applyRobustSuggested(){
    const x = currentX();
    const ap0 = Math.abs(aPrimeOfZ(x.z0, x)); // s^-2

    const dz = Math.max(0.005, Math.min(0.02, 0.2*x.z0));
    const kmin = Math.max(10, Math.min(120, 0.6*ap0));

    el("deltaZ").value = dz.toFixed(3);
    el("kappaMin").value = Math.round(kmin).toString();
    el("epsBand").value = "0.02";
    el("gapZ").value = "0.004";
    el("rcEnable").value = "yes";
    update();
  }

  // ---------------------------
  // Wire events
  // ---------------------------
  const ids = [
    "R","h","z0","m","eta","lam","beta","tau","profile",
    "zClear","Amax","Vmax","Pmax","rhomax","useCaps",
    "rcEnable","deltaZ","epsBand","gapZ","kappaMin","rcSamples",
    "dragC","zKick","simT","simDt","driveA","driveF","drivePhi","driveOn"
  ];
  ids.forEach(id=>{
    el(id).addEventListener("input", update);
    el(id).addEventListener("change", update);
  });

  el("optApply").addEventListener("click", ()=>runOpt(true));
  el("optOnly").addEventListener("click", ()=>runOpt(false));
  el("reset").addEventListener("click", resetDefaults);
  el("rcAuto").addEventListener("click", applyRobustSuggested);

  // Critical damping helper: set c ≈ 2ω0
  el("setCrit").addEventListener("click", () => {
    const x = currentX();
    const w0 = omega0Estimate(x);
    if (!Number.isFinite(w0)){
      alert("No stable ω₀ estimate (a'(z0) is not negative).");
      return;
    }
    const cCrit = 2 * w0;
    el("dragC").value = cCrit.toFixed(3);
  });

  el("runSim").addEventListener("click", () => {
    const x = currentX();
    const rb = currentRobust();

    const c = Math.max(0, parseFloat(el("dragC").value) || 0);
    const zKick = parseFloat(el("zKick").value) || 0;
    const T = Math.max(0.1, parseFloat(el("simT").value) || 5);
    const dt = Math.max(1e-4, parseFloat(el("simDt").value) || 0.002);

    const drive = {
      on: (el("driveOn")?.value || "no") === "yes",
      A: parseFloat(el("driveA")?.value || "0"),
      f: parseFloat(el("driveF")?.value || "0"),
      phi: parseFloat(el("drivePhi")?.value || "0"),
    };

    const data = simulateTimeSeries(x, rb, c, zKick, T, dt, drive);
    drawSim(el("sim").getContext("2d"), data, x, rb);

    const stats = computeSimStats(data, x, rb);
    const ok = stats.fracOutside < 0.01;
    el("dotSim").className = "dot " + (ok ? "good" : "warn");
    el("simStatsTxt").textContent =
      `z_min=${stats.zMin.toFixed(6)} m\n` +
      `z_max=${stats.zMax.toFixed(6)} m\n` +
      `peak-to-peak=${stats.p2p.toFixed(6)} m\n` +
      `max |z-z0|=${stats.maxAbsDev.toFixed(6)} m\n` +
      `% time outside band=${(100*stats.fracOutside).toFixed(2)}%`;
  });

  update();
})();
</script>
</body>
</html>